<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Using of Synchronous Discrete Time System paradigm in software development</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><link rel="home" href="#id2549220" title="Using of Synchronous Discrete Time System paradigm in software development"><link rel="next" href="#id2574678" title="Glossary"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" title="Using of Synchronous Discrete Time System paradigm in software development"><div class="titlepage"><div><div><h2 class="title"><a name="id2549220"></a>Using of Synchronous Discrete Time System paradigm in software development</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Yuri</span> <span class="surname">Borisov</span></h3><code class="email">&lt;<a class="email" href="mailto:yuri.borisov.v@gmail.com">yuri.borisov.v@gmail.com</a>&gt;</code></div></div><div><p class="releaseinfo">Ver.0.03 at 09-Dec-2010</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.01</td><td align="left">10-Mar-2010</td><td align="left">Yuri Borisov</td></tr><tr><td align="left" colspan="3">Initial version</td></tr><tr><td align="left">Revision 0.02</td><td align="left">21-May-2010</td><td align="left">Anna Lemekhova</td></tr><tr><td align="left" colspan="3">Added <a class="xref" href="#sec_rs_flipflop" title="Example: SR flip-flop">the section called &#8220;Example: SR flip-flop&#8221;</a></td></tr><tr><td align="left">Revision 0.03</td><td align="left">09-Dec-2010</td><td align="left">Yuri Borisov</td></tr><tr><td align="left" colspan="3">Added <a class="xref" href="#sec_snails" title="Examle: Snails">the section called &#8220;Examle: Snails&#8221;</a></td></tr></table></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="glossary"><a href="#id2574678">Glossary</a></span></dt><dt><span class="sect1"><a href="#sec_intro">Introduction</a></span></dt><dt><span class="sect1"><a href="#id2572792">Discrete Dynamic System introduction</a></span></dt><dt><span class="sect1"><a href="#id2563322">A short view to finite automata</a></span></dt><dt><span class="sect1"><a href="#id2569595">SW design approach using DDS and FSA</a></span></dt><dt><span class="sect1"><a href="#sec_fap">Framework for DDS paradigm</a></span></dt><dt><span class="sect1"><a href="#sec_snails">Examle: Snails</a></span></dt><dt><span class="sect1"><a href="#sec_rs_flipflop">Example: SR flip-flop</a></span></dt></dl></div><div class="bibliolist" title="References"><p class="title"><b>References</b></p><div class="biblioentry" title="Using of finite automata in SW disign [RU]"><a name="ref_scraft_ru_auto"></a><p>[<abbr class="abbrev">SCRAFT_RU_AUTO</abbr>] <span class="productname"><a class="ulink" href="http://workbort.ru/auto.shtml.htm" target="_top">http://workbort.ru/auto.shtml.htm</a>. </span><span class="title"><i>Using of finite automata in SW disign [RU]</i>. </span></p></div><div class="biblioentry" title="&#1051;&#1102;&#1073;&#1095;&#1077;&#1085;&#1082;&#1086; &#1042;.C., &#1050;&#1086;&#1085;&#1077;&#1095;&#1085;&#1086;-&#1072;&#1074;&#1090;&#1086;&#1084;&#1072;&#1090;&#1085;&#1072;&#1103; &#1090;&#1077;&#1093;&#1085;&#1086;&#1083;&#1086;&#1075;&#1080;&#1103; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103;"><a name="ref_sc_lubch_abp_1"></a><p>[<abbr class="abbrev">SC_LUBCH_ABP_1</abbr>] <span class="productname"><a class="ulink" href="http://www.softcraft.ru/design/katech.shtml" target="_top">http://www.softcraft.ru/design/katech.shtml</a>. </span><span class="title"><i>&#1051;&#1102;&#1073;&#1095;&#1077;&#1085;&#1082;&#1086; &#1042;.C., &#1050;&#1086;&#1085;&#1077;&#1095;&#1085;&#1086;-&#1072;&#1074;&#1090;&#1086;&#1084;&#1072;&#1090;&#1085;&#1072;&#1103; &#1090;&#1077;&#1093;&#1085;&#1086;&#1083;&#1086;&#1075;&#1080;&#1103; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103;</i>. </span></p></div><div class="biblioentry" title="Dynamical system. From Wikipedia, the free encyclopedia"><a name="ref_wiki_ds"></a><p>[<abbr class="abbrev">WIKI_DS</abbr>] <span class="productname"><a class="ulink" href="http://en.wikipedia.org/wiki/Dynamical_system" target="_top">http://en.wikipedia.org/wiki/Dynamical_system</a>. </span><span class="title"><i>Dynamical system. From Wikipedia, the free encyclopedia</i>. </span></p></div><div class="biblioentry" title="Discrete time Dynamical system. From Wikipedia, the free encyclopedia"><a name="ref_wiki_dds"></a><p>[<abbr class="abbrev">WIKI_DDS</abbr>] <span class="productname"><a class="ulink" href="http://en.wikipedia.org/wiki/Discrete-time_dynamical_system" target="_top">http://en.wikipedia.org/wiki/Discrete-time_dynamical_system</a>. </span><span class="title"><i>Discrete time Dynamical system. From Wikipedia, the free encyclopedia</i>. </span></p></div><div class="biblioentry" title="dynamical-systems.org"><a name="ref_ds_org"></a><p>[<abbr class="abbrev">DS_ORG</abbr>] <span class="productname"><a class="ulink" href="http://www.dynamical-systems.org/" target="_top">http://www.dynamical-systems.org/</a>. </span><span class="title"><i>dynamical-systems.org</i>. </span></p></div><div class="biblioentry" title="&#1051;&#1102;&#1073;&#1095;&#1077;&#1085;&#1082;&#1086; &#1042;.&#1057;. &#1048;&#1089;&#1082;&#1091;&#1089;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; ... RS-&#1090;&#1088;&#1080;&#1075;&#1075;&#1077;&#1088;&#1072;?!"><a name="ref_lyubch_rs_trig"></a><p>[<abbr class="abbrev">LYUBCH_RS_TRIG</abbr>] <span class="productname"><a class="ulink" href="http://workbort.ru/auto/ka/rsm/rsm01.shtml.htm" target="_top">http://workbort.ru/auto/ka/rsm/rsm01.shtml.htm</a>. </span><span class="title"><i>&#1051;&#1102;&#1073;&#1095;&#1077;&#1085;&#1082;&#1086; &#1042;.&#1057;.  &#1048;&#1089;&#1082;&#1091;&#1089;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; ... RS-&#1090;&#1088;&#1080;&#1075;&#1075;&#1077;&#1088;&#1072;?! </i>. </span></p></div><div class="biblioentry" title="Flip-flop (electronics). From Wikipedia, the free encyclopedia"><a name="ref_wiki_rs_trig"></a><p>[<abbr class="abbrev">WIKI_RS_TRIG</abbr>] <span class="productname"><a class="ulink" href="http://en.wikipedia.org/wiki/Flip-flop_(electronics)" target="_top">http://en.wikipedia.org/wiki/Flip-flop_(electronics)</a>. </span><span class="title"><i>Flip-flop (electronics). From Wikipedia, the free encyclopedia</i>. </span></p></div><div class="biblioentry" title="Finite-state machine. From Wikipedia, the free encyclopedia"><a name="ref_wiki_fsa"></a><p>[<abbr class="abbrev">WIKI_FSA</abbr>] <span class="productname"><a class="ulink" href="http://en.wikipedia.org/wiki/Finite_state_machine" target="_top">http://en.wikipedia.org/wiki/Finite_state_machine</a>. </span><span class="title"><i>Finite-state machine. From Wikipedia, the free encyclopedia</i>. </span></p></div><div class="biblioentry" title="Automata theory. From Wikipedia, the free encyclopedia"><a name="ref_wiki_aut_theory"></a><p>[<abbr class="abbrev">WIKI_AUT_THEORY</abbr>] <span class="productname"><a class="ulink" href="http://en.wikipedia.org/wiki/Automata_theory" target="_top">http://en.wikipedia.org/wiki/Automata_theory</a>. </span><span class="title"><i>Automata theory. From Wikipedia, the free encyclopedia</i>. </span></p></div><div class="biblioentry" title="Christos Cassandras, Stefane Lafortune. Introduction to Discrete Event System."><a name="ref_cass_intr_des"></a><p>[<abbr class="abbrev">CASS_INTR_DES</abbr>] <span class="productname"><a class="ulink" href="http://books.tr200.ru/v.php?id=242379" target="_top">http://books.tr200.ru/v.php?id=242379</a>. </span><span class="title"><i>Christos Cassandras, Stefane Lafortune. Introduction to Discrete Event System. </i>. </span></p></div><div class="biblioentry" title="FAP project git repository"><a name="ref_fap_git"></a><p>[<abbr class="abbrev">FAP_GIT</abbr>] <span class="productname"><a class="ulink" href="http://gitorious.org/fap" target="_top">http://gitorious.org/fap</a>. </span><span class="title"><i><a class="xref" href="#gls_fap" title="FAP">FAP</a> project git repository</i>. </span></p></div><div class="biblioentry" title='FAP demo application "Snails" git repository'><a name="ref_fap_demo_snails"></a><p>[<abbr class="abbrev">FAP_DEMO_SNAILS</abbr>] <span class="productname"><a class="ulink" href="http://gitorious.org/fap/fap-snails" target="_top">http://gitorious.org/fap/fap-snails</a>. </span><span class="title"><i><a class="xref" href="#gls_fap" title="FAP">FAP</a> demo application "Snails" git repository</i>. </span></p></div></div><div class="glossary" title="Glossary"><div class="titlepage"><div><div><h2 class="title"><a name="id2574678"></a>Glossary</h2></div></div></div><dl><dt><a name="gls_dtds"></a>DTDS</dt><dd><p>Discrete Time Dynamic System </p><p>See Also <a class="glossseealso" href="#gls_dtds1">Discrete Time Dynamic System</a>.</p></dd><dt><a name="gls_dtds1"></a>Discrete Time Dynamic System</dt><dd><p>The some phenomenom "black box" model based on input - internal states - output. 
		    Ref <a class="xref" href="#ref_wiki_ds" title="Dynamical system. From Wikipedia, the free encyclopedia">[<abbr class="abbrev">WIKI_DS</abbr>]</a> for base info.</p><p>See Also <a class="glossseealso" href="#gls_dtds">DTDS</a>.</p></dd><dt><a name="gls_dds"></a>DDS</dt><dd><p>Discrete Dynamic System. One more term for <a class="xref" href="#gls_dtds1" title="Discrete Time Dynamic System">Discrete Time Dynamic System</a></p></dd><dt><a name="gls_des"></a>DES</dt><dd><p>Discrete Event System - a class of <a class="xref" href="#gls_dtds" title="DTDS">DTDS</a>,  discrete state, event driven dynamic system.</p><p>Ref <a class="xref" href="#ref_cass_intr_des" title="Christos Cassandras, Stefane Lafortune. Introduction to Discrete Event System.">[<abbr class="abbrev">CASS_INTR_DES</abbr>]</a></p></dd><dt><a name="gls_dso_mbp"></a>DSO-MBP</dt><dd><p>Dynamic System Oriented Model Based Programming </p><p>See Also <a class="glossseealso" href="#gls_simulink">Simulink</a>.</p></dd><dt><a name="gls_distr_state_aut"></a>DSA</dt><dd><p>Distributed State Automation.</p></dd><dt><a name="gls_finite_automata"></a>FSA</dt><dd><p>Finite State automata</p></dd><dt><a name="gls_fap"></a>FAP</dt><dd><p>Finite Automata Paradigm framework. The framework for SW development with using of 
		    <a class="xref" href="#gls_finite_automata" title="FSA">FSA</a>paradigm.</p><p>Ref <a class="xref" href="#ref_fap_git" title="FAP project git repository">[<abbr class="abbrev">FAP_GIT</abbr>]</a> for source code repository</p></dd><dt><a name="gls_simulink"></a>Simulink</dt><dd><p>The modelling tool of Discrete Dynamic Systems</p></dd></dl></div><div class="sect1" title="Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_intro"></a>Introduction</h2></div></div></div><p>Discrete time dynamic system (<a class="xref" href="#gls_dds" title="DDS">DDS</a>) is one of the paradigms that can be used for SW development.</p><p> The key specifics of this paradigm are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Native parallelism - the model consists of interconnected automata</li><li class="listitem">Events based approach - the system variables are updated only on event received </li></ul></div><p>The paradigm has tough relation to concept of <a class="xref" href="#gls_finite_automata" title="FSA">FSA</a>.</p></div><div class="sect1" title="Discrete Dynamic System introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2572792"></a>Discrete Dynamic System introduction</h2></div></div></div><p>Let's consider the concept of <a class="xref" href="#gls_dds" title="DDS">DDS</a> first. 
	    The generic discrete time system can be considered as a "black box" with <span class="emphasis"><em>m</em></span> 
	    input variables <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>k</em></span> output variables <span class="emphasis"><em>z</em></span>, 
	    which value can be changed in the ticks of discrete time <span class="emphasis"><em>i</em></span>:</p><p><img src="fig_system_1.png"></p><p>Also we can introduce internal variables (states) <span class="emphasis"><em>s(k,i)</em></span> that determine system behaviour. 
	    Discrete time <span class="emphasis"><em>i</em></span> is unite for the system and "synchronyze" 
	    the sets of inputs, outputs and states. So this system can be called "synchronous"</p><p>One more resriction is that the set of inputs, states, and output values (alphabet) is finite. </p><p>Refer to <a class="xref" href="#ref_wiki_dds" title="Discrete time Dynamical system. From Wikipedia, the free encyclopedia">[<abbr class="abbrev">WIKI_DDS</abbr>]</a> section "General definition" for the formal definition.</p><p>A discrete time dynamical system can be represented by the tuple <span class="emphasis"><em>(T, S, F, G, X, Z, s0)</em></span> 
	    where, </p><table border="0" summary="Simple list" class="simplelist"><tr><td><span class="emphasis"><em>T</em></span> is a discrete time </td></tr><tr><td><span class="emphasis"><em>S</em></span> is a set called state space</td></tr><tr><td><span class="emphasis"><em>X</em></span> is the  set of inputs values</td></tr><tr><td><span class="emphasis"><em>Z</em></span> is the  set of output values</td></tr><tr><td><span class="emphasis"><em>s0</em></span> is an initial state of the system</td></tr><tr><td><span class="emphasis"><em>G</em></span> is a function that called "output function"</td></tr><tr><td><span class="emphasis"><em>F</em></span> is a function that called "evolution function"</td></tr><tr><td> <div class="informalequation"><a name="eq_3"></a><span class="mathphrase">F : U &#8834; X &#10799; S &#10230; S</span></div> </td></tr></table><p>Another representation form of DDS is:</p><table border="0" summary="Simple list" class="simplelist"><tr><td>
		<div class="informalequation"><a name="eq_4"></a><div class="literallayout"><p><span class="mathphrase">s(i) = F(i, s(i-1), x(i))</span>     <span>(4)</span></p></div></div> </td></tr><tr><td> 
		    <div class="informalequation"><a name="eq_5"></a><div class="literallayout"><p><span class="mathphrase">z(i) = G(i, s(i), x(i))</span>     <span>(5)</span></p></div></div> </td></tr></table><p>In many cases the status <span class="emphasis"><em>s</em></span>, inputs <span class="emphasis"><em>x</em></span>, and outputs <span class="emphasis"><em>z</em></span> can be represented 
	    by the vectors:</p><div class="informalequation"><span class="mathphrase">s = [s0, s1, ..., sn] </span></div><div class="informalequation"><span class="mathphrase">x = [x0, x1, ..., xm] </span></div><div class="informalequation"><span class="mathphrase">z = [z0, z1, ..., zk] </span></div><p>The element of status will be called "state variable" or "state" below while 
	    for the vector <span class="emphasis"><em>s</em></span> will be term "system state" used</p><p>This can be represented by the scheme below:</p><p></p><div class="figure"><a name="fig_dds_repr1"></a><p class="title"><b>Figure 1. DDS scheme</b></p><div class="figure-contents"><img src="fig_system_str.png" alt="DDS scheme"></div></div><br class="figure-break"><p> </p></div><div class="sect1" title="A short view to finite automata"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2563322"></a>A short view to finite automata</h2></div></div></div><p>Ref <a class="xref" href="#ref_wiki_aut_theory" title="Automata theory. From Wikipedia, the free encyclopedia">[<abbr class="abbrev">WIKI_AUT_THEORY</abbr>]</a> for WiKi article with math base of <a class="xref" href="#gls_finite_automata" title="FSA">FSA</a></p><p>FSA can be considered as a class of synchronous system that is characterised by six-tuple:</p><p>G = (X, Y, S, f, g, s0)</p><p>where</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">X - input alphabet</li><li class="listitem">Z - output alphabet</li><li class="listitem">S - set of states</li><li class="listitem">f - transion function</li><li class="listitem">g - output function</li><li class="listitem">s0 - initial state</li></ul></div><p>and</p><table border="0" summary="Simple list" class="simplelist"><tr><td>
		<div class="literallayout"><p><div class="informalequation"><a name="eq_1"></a>s(i) = f(x(i), s(i-1)                <span><a name="eq_1_label"></a>(1)</span></div></p></div>
	    </td></tr><tr><td>
		<div class="literallayout"><p><div class="informalequation"><a name="eq_2"></a>z(i) = g(x(i), s(i))                 <span><a name="eq_2_label"></a>(2)</span></div></p></div>
	    </td></tr></table><p>It can be noted that the term "state" is used differently for FSA and DDS: for FSA it often means the element of states set, i.e state value, 
	    while for DDS it ofter means "state variable"</p></div><div class="sect1" title="SW design approach using DDS and FSA"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2569595"></a>SW design approach using DDS and FSA</h2></div></div></div><p>Consider SW system design based on DDS representation <a class="xref" href="#fig_dds_repr1" title="Figure 1. DDS scheme">Figure 1, &#8220;DDS scheme&#8221;</a></p><p>Basing on representation of whole system state <span class="emphasis"><em>s</em></span> as a vector of system state elements variables
	    <span class="emphasis"><em>sk</em></span>, the equation <a class="xref" href="#eq_4">(4)</a> can be written via set of equations for each variable:</p><div class="informalequation"><a name="eq_6"></a><div class="literallayout"><p><span class="mathphrase">sk(i) = Fk(i, sk(i-1), x(i))</span>     <span><a name="eq_6_label"></a>(6)</span></p></div></div><p>where</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Fk - transition function for state variable sk</li></ul></div><p>So the whole system can be factored into the set of particular state variables with assosiated transition functions</p><p>Lets also assume that system can be created as a set of subsystems, that can interact one to another, i.e be connected.</p><p>As can be seen from the <a class="xref" href="#fig_dds_repr1" title="Figure 1. DDS scheme">Figure 1, &#8220;DDS scheme&#8221;</a> each state variables is finite automata where set of state is the 
	    set of possible values of state variable, and input events are the state variable inputs values. </p><p>Then the whole scheme can be created with two kinds of elements - state variable and object (sybsystem):</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">State variable includes the variable, transition function, and set of inputs</li><li class="listitem">Object includes one or more state variables, one or more sub-objects and connections between them</li></ul></div><p>Let's illustrate the approach using the examples of systems implementation. To simplify analysis of the examples we can
	use graphic notation for the object and state.</p><p>Graphic notation for the state can be as:</p><p><img src="fig_state_notation_1.png"></p><p>State notation includes:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">State name - uniquely identifies the state within an object</li><li class="listitem">State type - uniquely identifies the type of state. Actually it identifies the type of data, for instance Boolean, etc.</li><li class="listitem">State input name-  uniquely identifies input, the name used within transtion function. Also the type of input are specified.</li><li class="listitem">Transion function - is specified via identificator and/or the description of function</li></ul></div><p>The scheme of system then consists of states and "links" that connect state to other state depending on it.</p><p>In order to simplify object as a syblystem we can separate all the states of the object into three groups:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Regular states - or internal states, hidden for access from other sybsystem</li><li class="listitem">Input states - can be accessed from out of object and can be set as dependent on other object output states</li><li class="listitem">Outpus states - can be accesses form out of object and can be used as states 
		from which connected object's input states are dependent on</li></ul></div></div><div class="sect1" title="Framework for DDS paradigm"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_fap"></a>Framework for DDS paradigm</h2></div></div></div><p>There was the framework <a class="xref" href="#gls_fap" title="FAP">FAP</a> created for the purpose of modelling and analysing DDS paradigm in SW development. Ref
	    <a class="xref" href="#ref_fap_git" title="FAP project git repository">[<abbr class="abbrev">FAP_GIT</abbr>]</a> for source code repository</p><p>Below is the structure and APIs of the FAP libraries outlined:</p><div class="figure"><a name="fig_fap_clsdgm"></a><p class="title"><b>Figure 2. </b></p><div class="figure-contents"><img src="fig_fap_clsdgm.png"></div></div><br class="figure-break"><p>The structure of system is described by system spec - XML document, that specified the sybsystem and connections between them.</p><p>FAP libraries were used for develop examples given in the current article.</p></div><div class="sect1" title="Examle: Snails"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_snails"></a>Examle: Snails</h2></div></div></div><p>Let's illustrate the idea of FSA using with the example - simple application where the race of three snails simulated. 
	    The snail in this action does two thinks: moving and eating. The leader in the race gets more food so increases his weigth. But the more weigth is snail,
	the less velocity he moves.</p><p>Let's simulate state by the subsystem, containing state variables for the weight and coordinate on race-track.</p><div class="figure"><a name="fig_snails_snail_str"></a><p class="title"><b>Figure 3. </b></p><div class="figure-contents"><img src="fig_snails_snail_str.png"></div></div><br class="figure-break"><p>The whole system includes three snails and connection between them. The diagram below shows the system structure for two snails.</p><div class="figure"><a name="fig_snails_str"></a><p class="title"><b>Figure 4. </b></p><div class="figure-contents"><img src="fig_snails_str.png"></div></div><br class="figure-break"><p>Let's create FAP spec for the system:</p><div class="example"><a name="exm_snails_spec"></a><p class="title"><b>Example 1. Snails spec</b></p><div class="example-contents"><pre class="programlisting">
	     
	    &lt;caeenv&gt;
		&lt;object type="test" id="main_test"&gt;

		    &lt;!-- *************************** SNAIL BASE *******************************  --&gt;
		    &lt;object type="none" id="snail" quiet="yes"&gt; 
			&lt;logspec  event="cre"&gt; &lt;logdata id="new"/&gt; &lt;/logspec&gt;

			&lt;state type="StUint32" id="mass" access="Inp" transf="trans_mass" init="2"&gt; 
			    &lt;logspec event="upd"&gt; &lt;logdata id="new"/&gt; &lt;/logspec&gt; 
			    &lt;inp id="coord_self"/&gt; &lt;inp id="coord_others.*"/&gt; &lt;/state&gt;

			&lt;state type="StUint32" id="coord" len="4" access="Out" transf="trans_coord" init="0"&gt; 
			    &lt;logspec event="upd"&gt; &lt;logdata id="cur"/&gt; &lt;logdata id="new"/&gt; &lt;/logspec&gt; 
			    &lt;inp id="self"/&gt; &lt;inp id="mass"/&gt; &lt;/state&gt;

			&lt;conn state="mass"&gt; &lt;dep inp="coord_self" conn="coord"/&gt; &lt;/conn&gt;
			&lt;conn state="coord"&gt; &lt;dep inp="self" conn="coord"/&gt; &lt;dep inp="mass" conn="mass"/&gt; &lt;/conn&gt;
		    &lt;/object&gt; &lt;!-- snail --&gt;

		    &lt;!-- *************************** SNAIL INSTANCES *******************************  --&gt;
		    &lt;object type="snail" id="snail_1" &gt; &lt;state mut="Change" id="mass" init="7"/&gt;&lt;/object&gt;
		    &lt;object type="snail" id="snail_2" &gt; &lt;state mut="Change" id="mass" init="3"/&gt;&lt;/object&gt;
		    &lt;object type="snail" id="snail_3" &gt; &lt;state mut="Change" id="mass" init="16"/&gt;&lt;/object&gt;


		    &lt;!-- *************************** CONNECTIONS *******************************  --&gt;
		    &lt;conn state="snail_1.mass"&gt; &lt;dep inp="coord_others.1" conn="snail_2.coord"/&gt; &lt;dep inp="coord_others.2" conn="snail_3.coord"/&gt; &lt;/conn&gt;
		    &lt;conn state="snail_2.mass"&gt; &lt;dep inp="coord_others.1" conn="snail_1.coord"/&gt; &lt;dep inp="coord_others.2" conn="snail_3.coord"/&gt; &lt;/conn&gt;
		    &lt;conn state="snail_3.mass"&gt; &lt;dep inp="coord_others.1" conn="snail_1.coord"/&gt; &lt;dep inp="coord_others.2" conn="snail_2.coord"/&gt; &lt;/conn&gt;

		&lt;/object&gt; &lt;!-- test --&gt;
	    &lt;/caeenv&gt;
	    
	</pre></div></div><br class="example-break"><p>We also can implement transition functions for snail coordinate and mass:</p><div class="example"><a name="id2544970"></a><p class="title"><b>Example 2. </b></p><div class="example-contents"><pre class="programlisting">
	    
void update_mass(CAE_Object* /*aObject*/, CAE_State* aState)
{
    CAE_TState&lt;TUint32&gt;&amp; self = (CAE_TState&lt;TUint32&gt;&amp;) *aState;
    const TUint32&amp; coord_s = self.Inp("coord_self");

    TInt feed = KMaxFeed;
    for (TInt i = 1; self.Input("coord_others", i) != NULL; i++) {
	const TUint32&amp; coord_o = self.Inp("coord_others", i);
	if (coord_o &gt; coord_s &amp;&amp; feed &gt; 0)
	    feed--;
    }
    TUint32 newmass = ~self + feed - 1;
    self = (newmass &gt; KMass_Max) ? KMass_Max: ((newmass &lt; KMass_Min) ? KMass_Min : newmass);
}

void update_coord(CAE_Object* /*aObject*/, CAE_State* aState)
{
    CAE_TState&lt;TUint32&gt;&amp; self = (CAE_TState&lt;TUint32&gt;&amp;) *aState;
    const TUint32&amp; mass_s = self.Inp("mass");
    self = ~self + KMass_Max/mass_s;
}
	    
	</pre></div></div><br class="example-break"><p>And finally we create automata environment, and run the automata time</p><pre class="programlisting">
	iEnv = CAE_Env::NewL(NULL, tinfos, KSpecFileName, 1, NULL, KLogFileName);
    </pre><p>The source code of application can be accessed on repository <a class="xref" href="#ref_fap_demo_snails" title='FAP demo application "Snails" git repository'>[<abbr class="abbrev">FAP_DEMO_SNAILS</abbr>]</a></p></div><div class="sect1" title="Example: SR flip-flop"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_rs_flipflop"></a>Example: SR flip-flop</h2></div></div></div><p>Lets simulate work of SR flip-flop <a class="xref" href="#ref_wiki_rs_trig" title="Flip-flop (electronics). From Wikipedia, the free encyclopedia">[<abbr class="abbrev">WIKI_RS_TRIG</abbr>]</a> using DDS.</p><p>It is possible to construct SR flip-flop using either two NOR or two NAND gate.</p><p>The SR NAND gate latch:</p><p></p><p>
	<img src="fig_sr_01.png" align="middle">
    </p><p>The boolean formula:
	<table border="0" summary="Simple list" class="simplelist"><tr><td>Q = !(!S &amp; NQ)</td></tr><tr><td>NQ = !(!R &amp; Q)</td></tr></table>
    </p><p>R (reset) and S (set) are known as external inputs. 
	Q is known as external output and NQ is its inverse output.
	There is feedback from each output to one of gate inputs.
	The problematic of SR flip-flop programming is related to these feedback,
	as additional synchronization actions to perform calculation are required.</p><p>When having initial input values at t=t0 (Q(t0)=Q0, NQ(t0)=NQ0, S(t0)=S0, R(t0)=R0), 
	the next step results at t=t1 can be obtained after applying boolean NAND operation twice:
	<table border="0" summary="Simple list" class="simplelist"><tr><td>Step 1:</td><td>Qint = !(!S0 &amp; NQ0)</td><td>Step 2:</td><td>Q1 = !(!S0 &amp; NQint)</td></tr><tr><td></td><td>NQint = !(!R0 &amp; Q0)</td><td></td><td>NQ1 = !(!R0 &amp; Qint)</td></tr></table>
    </p><p>Generally there are four possible combinations of (Q, NQ). 
	But from trigger point of view only (0,1) and (1,0) are correct. 
	They are known as stable states (state (Q1, NQ1)). 
	(1,1) is an intermediate (Qint, NQint) unstable state. 
	All transitions between stable states are performed through intermediate state. 
	This is push-pull (in-out) trigger scheme. 
	The diagram below <a class="xref" href="#ref_lyubch_rs_trig" title="&#1051;&#1102;&#1073;&#1095;&#1077;&#1085;&#1082;&#1086; &#1042;.&#1057;. &#1048;&#1089;&#1082;&#1091;&#1089;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; ... RS-&#1090;&#1088;&#1080;&#1075;&#1075;&#1077;&#1088;&#1072;?!">[<abbr class="abbrev">LYUBCH_RS_TRIG</abbr>]</a> describes the process and conditions of states switching:
    </p><p></p><p><img src="fig_sr_03.png"></p><p>In <a class="xref" href="#ref_lyubch_rs_trig" title="&#1051;&#1102;&#1073;&#1095;&#1077;&#1085;&#1082;&#1086; &#1042;.&#1057;. &#1048;&#1089;&#1082;&#1091;&#1089;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; ... RS-&#1090;&#1088;&#1080;&#1075;&#1075;&#1077;&#1088;&#1072;?!">[<abbr class="abbrev">LYUBCH_RS_TRIG</abbr>]</a> the pros and cons of several SR flip-flop models are described, 
	among them there are sequential flowchart model,
	parallel synchronous FSA model (our FAPWS is exactly such case) 
	and asynchronous Petri net model. 
	It will take time and efforts for an uninformed reader to investigate all these schemes and graphs. 
	Petri net is far-fetched here, of course it is more suitable for asynchronous systems.
	So it makes no sense to evaluate it.</p><p>When having no additional tools (except C or C++) I would choose sequential variant with explicit intermediate state (SIS) 
	or "if" sequential option <a class="xref" href="#ref_lyubch_rs_trig" title="&#1051;&#1102;&#1073;&#1095;&#1077;&#1085;&#1082;&#1086; &#1042;.&#1057;. &#1048;&#1089;&#1082;&#1091;&#1089;&#1089;&#1090;&#1074;&#1086; &#1087;&#1088;&#1086;&#1075;&#1088;&#1072;&#1084;&#1084;&#1080;&#1088;&#1086;&#1074;&#1072;&#1085;&#1080;&#1103; ... RS-&#1090;&#1088;&#1080;&#1075;&#1075;&#1077;&#1088;&#1072;?!">[<abbr class="abbrev">LYUBCH_RS_TRIG</abbr>]</a>: </p><p><img src="fig_sr_04.png"></p><p><span class="emphasis"><em>Digression. Some simplification can be made:
	    <table border="0" summary="Simple list" class="simplelist"><tr><td>
		    Q1 = !(!S0 &amp; NQint) = !(!S0 &amp; (!(!R0 &amp; Q0))) = S0 | !R0 &amp; Q0 </td></tr></table>
	    In this case we don't need NQ at all, Q is defined by S, R and previous Q. But this is another model.
    </em></span></p><p>But having such tool as FAPWS library, I would prefer it. The reasons are the following:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">operation decrease: if in intermediate state S or/and R is changed, they will be used in generation. 
	    On one hand we miss stable state, but on the other hand we reduce number of operations. 
	    Let's illustrate this with input sequences:
	    <span class="emphasis"><em><table border="0" summary="Simple list" class="simplelist"><tr><td>(Q0,NQ0)=(1,0) SR_1= 01, 01, 01, 01, 01, 01, 01, 01, 10</td></tr><tr><td>FAPWS: (1,0) 01 -&gt; (1,1) 01 -&gt; (0,1) 01 -&gt; (0,1) 10 -&gt; (1,1) 10 -&gt; (1,0) 10</td></tr><tr><td>SIS: [(1,0) 01 -&gt; (1,1) 01 -&gt; (0,1) 01] -&gt;   [ (0,1) 01 -&gt; (0,1) 01]  7 times   -&gt; [(0,1) 10 -&gt; (1,1) 10 -&gt; (1,0) 10]</td></tr></table></em></span>
	    and:
	    <span class="emphasis"><em><table border="0" summary="Simple list" class="simplelist"><tr><td>(Q0,NQ0)=(1,0) SR_2 = 01, 10</td></tr><tr><td>FAPWS: (1,0) 01 -&gt; (1,1) 10 -&gt; (1,0) 10 - state is missed here</td></tr><tr><td>SIS: [(1,0) 01 -&gt; (1,1) 01 -&gt; (0,1) 01] -&gt;  [ (0,1) 10 -&gt; (1,1) 10 -&gt; (1,0) 10]</td></tr></table></em></span>
	    State skipping can be easily avoided by 2 step operations after each S or/and R setting.
	</li><li class="listitem">code decrease is achieved by:
	    <div class="orderedlist"><ol class="orderedlist" type="a"><li class="listitem">xml generation. All you need is xml spec and two transition functions registered in environment object</li><li class="listitem">no checks for data change is required</li></ol></div></li><li class="listitem">clear notation, support states of standard encapsulated data, states of user defined data can be added
	    <p class="simpara">The SR DDS notation:</p><p class="simpara"><img src="fig_sr_02.png"></p></li></ul></div><p>The conclusion is that DDS and its realization FAPWS library can be useful (and simplify our life) even in such a trivial example as SR flip-flop.</p></div></div></body></html>
