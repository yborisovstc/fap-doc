<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Using embedded transtion in Discrete Event System language interpreter</title><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"><meta name="description" content="The compact functional language was offered for using in discrete event system. The language can be used for specifying system variables transition function. The design and implementation of the language interpreter is outlined. It is shown that embedding transition language interpreter into the base discrete event system interpreter creates convenient environment for specifying and running the systems"><link rel="home" href="#id2590929" title="Using embedded transtion in Discrete Event System language interpreter"><link rel="next" href="#id2591429" title="Glossary"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" title="Using embedded transtion in Discrete Event System language interpreter"><div class="titlepage"><div><div><h2 class="title"><a name="id2590929"></a>Using embedded transtion in Discrete Event System language interpreter</h2></div><div><div class="author"><h3 class="author"><span class="firstname">Yuri</span> <span class="surname">Borisov</span></h3><code class="email">&lt;<a class="email" href="mailto:yuri.borisov.v@gmail.com">yuri.borisov.v@gmail.com</a>&gt;</code></div></div><div><p class="releaseinfo">Ver.0.02 at 07-Apr-2011</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Revision History</b></th></tr><tr><td align="left">Revision 0.01</td><td align="left">10-Mar-2011</td><td align="left">Yuri Borisov</td></tr><tr><td align="left" colspan="3">Initial version</td></tr><tr><td align="left">Revision 0.02</td><td align="left">07-Apr-2011</td><td align="left">Yuri Borisov</td></tr><tr><td align="left" colspan="3">Added <a class="xref" href="#sec_impl" title="Implementation of interpreter">the section called &#8220;Implementation of interpreter&#8221;</a></td></tr></table></div></div><div><div class="abstract" title="Abstract"><p class="title"><b>Abstract</b></p><p>The compact functional language was offered for using in discrete event system.
		The language can be used for specifying system variables transition function.</p><p>The design and implementation of the language interpreter is outlined. It is shown that
		embedding transition language interpreter into the base discrete event system interpreter creates 
		convenient environment for specifying and running the systems</p></div></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="glossary"><a href="#id2591429">Glossary</a></span></dt><dt><span class="sect1"><a href="#sec_intro">Introduction</a></span></dt><dt><span class="sect1"><a href="#sec_lang">The language for transtitions</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec_lang_intro">Introduction</a></span></dt><dt><span class="sect2"><a href="#sec_lang_syntax">Syntax</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec_mod">Modules</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec_mod_intro">Introduction</a></span></dt><dt><span class="sect2"><a href="#id2586712">Hierarchical modularity.</a></span></dt><dt><span class="sect2"><a href="#sec_mod_emb">Embedded module</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec_types">Type system</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec_types_intro">Introduction</a></span></dt><dt><span class="sect2"><a href="#sec_types_repr">Types representation</a></span></dt><dt><span class="sect2"><a href="#sec_types_constr">Types and constructors</a></span></dt><dt><span class="sect2"><a href="#sec_types_data">Types of data</a></span></dt><dt><span class="sect2"><a href="#sec_types_predef">Predefined types</a></span></dt><dt><span class="sect2"><a href="#sec_types_userdef">User defined type</a></span></dt><dt><span class="sect2"><a href="#sec_types_raw">Raw term type</a></span></dt><dt><span class="sect2"><a href="#sec_types_unknown">The case of unknown type</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec_eval">Expression evaluation</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec_eval_rules">Evaluation rules</a></span></dt><dt><span class="sect2"><a href="#sec_eval_res">Arguments resolution using type information</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec_impl">Implementation of interpreter</a></span></dt><dt><span class="sect1"><a href="#sec_snails">Example: Snails</a></span></dt><dd><dl><dt><span class="sect2"><a href="#sec_snails_vs">"Snails with DESL vs. Snails with C++ transitions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#sec_disc">Discussion</a></span></dt></dl></div><div class="bibliolist" title="References"><p class="title"><b>References</b></p><div class="biblioentry" title="Dynamical system. From Wikipedia, the free encyclopedia"><a name="ref_wiki_ds"></a><p>[<abbr class="abbrev">WIKI_DS</abbr>] <span class="productname"><a class="ulink" href="http://en.wikipedia.org/wiki/Dynamical_system" target="_top">http://en.wikipedia.org/wiki/Dynamical_system</a>. </span><span class="title"><i>Dynamical system. From Wikipedia, the free encyclopedia</i>. </span></p></div><div class="biblioentry" title="Discrete time Dynamical system. From Wikipedia, the free encyclopedia"><a name="ref_wiki_dds"></a><p>[<abbr class="abbrev">WIKI_DDS</abbr>] <span class="productname"><a class="ulink" href="http://en.wikipedia.org/wiki/Discrete-time_dynamical_system" target="_top">http://en.wikipedia.org/wiki/Discrete-time_dynamical_system</a>. </span><span class="title"><i>Discrete time Dynamical system. From Wikipedia, the free encyclopedia</i>. </span></p></div><div class="biblioentry" title="Finite-state machine. From Wikipedia, the free encyclopedia"><a name="ref_wiki_fsa"></a><p>[<abbr class="abbrev">WIKI_FSA</abbr>] <span class="productname"><a class="ulink" href="http://en.wikipedia.org/wiki/Finite_state_machine" target="_top">http://en.wikipedia.org/wiki/Finite_state_machine</a>. </span><span class="title"><i>Finite-state machine. From Wikipedia, the free encyclopedia</i>. </span></p></div><div class="biblioentry" title="Christos Cassandras, Stefane Lafortune. Introduction to Discrete Event System."><a name="ref_cass_intr_des"></a><p>[<abbr class="abbrev">CASS_INTR_DES</abbr>] <span class="productname"><a class="ulink" href="http://books.tr200.ru/v.php?id=242379" target="_top">http://books.tr200.ru/v.php?id=242379</a>. </span><span class="title"><i>Christos Cassandras, Stefane Lafortune. Introduction to Discrete Event System. </i>. </span></p></div><div class="biblioentry" title="Y.Borisov, A.Lemekhova. Using of Synchronous Discrete Time System paradigm in software development"><a name="ref_ybor_using_des"></a><p>[<abbr class="abbrev">YBOR_USING_DES_</abbr>] <span class="productname"><a class="ulink" href="http://gitorious.org/fap/doc_dsa_in_swd" target="_top">http://gitorious.org/fap/doc_dsa_in_swd</a>. </span><span class="title"><i>Y.Borisov, A.Lemekhova. Using of Synchronous Discrete Time System paradigm in software development</i>. </span></p></div><div class="biblioentry" title="FAP project git repository"><a name="ref_fap_git"></a><p>[<abbr class="abbrev">FAP_GIT</abbr>] <span class="productname"><a class="ulink" href="http://gitorious.org/fap" target="_top">http://gitorious.org/fap</a>. </span><span class="title"><i><a class="xref" href="#gls_fap" title="FAP">FAP</a> project git repository</i>. </span></p></div><div class="biblioentry" title='FAP demo application "Snails" git repository'><a name="ref_fap_demo_snails"></a><p>[<abbr class="abbrev">FAP_DEMO_SNAILS</abbr>] <span class="productname"><a class="ulink" href="http://gitorious.org/fap/fap-snails" target="_top">http://gitorious.org/fap/fap-snails</a>. </span><span class="title"><i><a class="xref" href="#gls_fap" title="FAP">FAP</a> demo application "Snails" git repository</i>. </span></p></div></div><div class="glossary" title="Glossary"><div class="titlepage"><div><div><h2 class="title"><a name="id2591429"></a>Glossary</h2></div></div></div><dl><dt><a name="gls_dtds"></a>DTDS</dt><dd><p>Discrete Time Dynamic System </p><p>See Also <a class="glossseealso" href="#gls_dtds1">Discrete Time Dynamic System</a>.</p></dd><dt><a name="gls_dtds1"></a>Discrete Time Dynamic System</dt><dd><p>The some phenomenom "black box" model based on input - internal states - output. 
		    Ref <a class="xref" href="#ref_wiki_ds" title="Dynamical system. From Wikipedia, the free encyclopedia">[<abbr class="abbrev">WIKI_DS</abbr>]</a> for base info.</p><p>See Also <a class="glossseealso" href="#gls_dtds">DTDS</a>.</p></dd><dt><a name="gls_dds"></a>DDS</dt><dd><p>Discrete Dynamic System. One more term for <a class="xref" href="#gls_dtds1" title="Discrete Time Dynamic System">Discrete Time Dynamic System</a></p></dd><dt><a name="gls_des"></a>DES</dt><dd><p>Discrete Event System - a class of <a class="xref" href="#gls_dtds" title="DTDS">DTDS</a>,  discrete state, event driven dynamic system.</p><p>Ref <a class="xref" href="#ref_cass_intr_des" title="Christos Cassandras, Stefane Lafortune. Introduction to Discrete Event System.">[<abbr class="abbrev">CASS_INTR_DES</abbr>]</a></p></dd><dt><a name="gls_dest"></a>DEST</dt><dd><p>Discrete Event System transition language - functional language for variable transition 
		    in <a class="xref" href="#gls_des" title="DES">DES</a> framework <a class="xref" href="#gls_fap" title="FAP">FAP</a></p></dd><dt><a name="gls_finite_automata"></a>FSA</dt><dd><p>Finite State automata</p></dd><dt><a name="gls_fap"></a>FAP</dt><dd><p>Finite Automata Paradigm framework. The framework for SW development with using of 
		    <a class="xref" href="#gls_finite_automata" title="FSA">FSA</a>paradigm.</p><p>Ref <a class="xref" href="#ref_fap_git" title="FAP project git repository">[<abbr class="abbrev">FAP_GIT</abbr>]</a> for source code repository</p></dd><dt><a name="gls_ebnf"></a>EBNF</dt><dd><p>Extended Backus&#8211;Naur Form. A family of metasyntax notations used for expressing context-free grammars: 
		    that is, a formal way to describe computer programming languages and other formal languages. 
		    They are extensions of the basic Backus&#8211;Naur Form (BNF) metasyntax notation.  </p></dd></dl></div><div class="sect1" title="Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_intro"></a>Introduction</h2></div></div></div><p>In the <a class="xref" href="#gls_fap" title="FAP">FAP</a> project the base <a class="xref" href="#gls_des" title="DES">DES</a> framework 
	    (ref <a class="xref" href="#ref_fap_git" title="FAP project git repository">[<abbr class="abbrev">FAP_GIT</abbr>]</a>) was created. It uses the language for specifying the
	    base element of the system - variables (states), dependencies (variable inputs), connections etc. The framework enables to
	    use regular function written with C, C++, and referred from the system difinition. </p><p>This approach is usefull when the framework is used within C++ program. In case of "standalone" <a class="xref" href="#gls_des" title="DES">DES</a>
	    solution it seems rather inconvenient. It would be more effecient if transitions are specified directly in system description.</p><p>This article outlines how such an approach can be implemented. We first describe the simple functional language 
	    <a class="xref" href="#gls_dest" title="DEST">DEST</a> for transition. 
	    Then we outline of how the language interpreter can be implemented and embedded into <a class="xref" href="#gls_des" title="DES">DES</a> 
	    interpretation framework. And finally the we look at the demo application, and compare the "regular" and embedded
	    approaches.</p></div><div class="sect1" title="The language for transtitions"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_lang"></a>The language for transtitions</h2></div></div></div><div class="sect2" title="Introduction"><div class="titlepage"><div><div><h3 class="title"><a name="sec_lang_intro"></a>Introduction</h3></div></div></div><p>Transition in <a class="xref" href="#gls_des" title="DES">DES</a> are the function that applies the system variable (state) inputs as the 
		arguments. Thus it is strong reason to use functional language for states transition.</p><p>The advantages here are as: </p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">The language meets the "nature" of the transitions</li><li class="listitem">There is possibility to use compact syntax</li><li class="listitem">Recursive notation can be used that allows simplifying of interpreter.</li></ul></div></div><div class="sect2" title="Syntax"><div class="titlepage"><div><div><h3 class="title"><a name="sec_lang_syntax"></a>Syntax</h3></div></div></div><p>Let's define the syntax of the language. We prefer to make the syntax simple and compact. 
		 Not strong <a class="xref" href="#gls_ebnf" title="EBNF">EBNF</a> notation can be specified:</p><pre class="programlisting">
		<table border="0" summary="Simple list" class="simplelist"><tr><td>&lt;program&gt; ::= { &lt;statement&gt;, &lt;linefeed&gt; }</td></tr><tr><td>&lt;linefeed&gt; ::= "\n"</td></tr><tr><td>&lt;statement&gt; ::= &lt;definition&gt; | &lt;expr&gt;</td></tr><tr><td>&lt;definition&gt; ::= "let", &lt;gap&gt;, &lt;name&gt;, [&lt;args&gt;], 
			[&lt;gap&gt;] "::", [&lt;gap&gt;], &lt;typespec&gt;, [[&lt;gap&gt;], ":=", [&lt;gap&gt;] &lt;expr&gt; ]</td></tr><tr><td>&lt;expr&gt; ::= &lt;terms&gt;</td></tr><tr><td>&lt;term&gt; ::= &lt;name&gt; | "(", terms, ")"</td></tr><tr><td>&lt;terms&gt; ::= &lt;term&gt;, {&lt;gap&gt;, &lt;term&gt;}</td></tr><tr><td>&lt;typespec&gt; ::= &lt;typename&gt;, { &lt;gap&gt;, &lt;typename&gt;} </td></tr><tr><td>&lt;typename&gt; ::= &lt;name&gt;</td></tr><tr><td>&lt;name&gt; ::= &lt;ascii-symbol&gt;, {&lt;ascii-symbol&gt; | &lt;ascii-digit&lt;}</td></tr></table>
	    </pre><p>The definition specifies simple expression or function depending on if it includes "args" or not </p><p>The exampes are:</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"> Simple definition:
		    <pre class="programlisting"> let infrontcnt :: TInt := count filter lt inp coord_self icothers </pre></li><li class="listitem"> Function definition:
		    <pre class="programlisting"> let restrbot x lim :: TInt TInt TInt := if lt x lim lim x</pre></li><li class="listitem"> Expression:
		    <pre class="programlisting">restr rmass KMinMass KMaxMass</pre></li></ul></div></div></div><div class="sect1" title="Modules"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_mod"></a>Modules</h2></div></div></div><div class="sect2" title="Introduction"><div class="titlepage"><div><div><h3 class="title"><a name="sec_mod_intro"></a>Introduction</h3></div></div></div><p><a class="xref" href="#gls_dest" title="DEST">DEST</a> has to support modules in order to reuse the existing functions within states transitions.
		Also the interpreter has to be adapted to specifics of base DES language as DEST is the part of it.</p></div><div class="sect2" title="Hierarchical modularity."><div class="titlepage"><div><div><h3 class="title"><a name="id2586712"></a>Hierarchical modularity.</h3></div></div></div><p>Looking at DES language we can see that the transition function runs in clearly specified context - 
		first it is the system variable which transition belongs to. Then the system that "owns" this variable, and so on.</p><p>So we can consider the nodes of systems hierarchy as the sources of available DEST modules.</p><p>This approach advantage is that we can isolate systems in term of available transitions. This also gives
		the functions unification to the base DES language and allows to consider DEST as a part of DES language. </p><div class="figure"><a name="fig_modules_01"></a><p class="title"><b>Figure 1. </b></p><div class="figure-contents"><img src="fig_modules_01.png"></div></div><br class="figure-break"></div><div class="sect2" title="Embedded module"><div class="titlepage"><div><div><h3 class="title"><a name="sec_mod_emb"></a>Embedded module</h3></div></div></div><p>There is standard module provided that contains the set of base expressions. This module is accessible by 
		default for any transitions. The standard module contains language embedded functions such standard data types 
		constructors, operations etc.</p></div></div><div class="sect1" title="Type system"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_types"></a>Type system</h2></div></div></div><div class="sect2" title="Introduction"><div class="titlepage"><div><div><h3 class="title"><a name="sec_types_intro"></a>Introduction</h3></div></div></div><p>The type system for DES transition language is important because the transition function intention is to handle tha data: 
		transition function receives the state inputs as the arguments and produces the state data in result.</p><p>Another important capability for the language is using user defined data. The current version of DES interpreter can specify 
		states with predefined types only, to use extended types we need to implement them as plugins.</p><p>This restriction can be avoided when user defined type is supported in DEST.</p></div><div class="sect2" title="Types representation"><div class="titlepage"><div><div><h3 class="title"><a name="sec_types_repr"></a>Types representation</h3></div></div></div><p>DEST specifies the types for all the terms. The type is specified in the form:</p><pre class="programlisting">
		type-res type-arg-n ... type-arg-1
	    </pre><p>Where "type-res" is the type of expression result, and "type-arg" is the type of argument</p><p>The first applied argument type is specified as rightmost one. So when the function applies to the argument,
		the type of result becomes as removing the righmost type element.</p><p>For example:</p><pre class="programlisting">
		let inc :: TInt TInt := add 1
		where
		the type of "add" is as "TInt TInt TInt"
	    </pre></div><div class="sect2" title="Types and constructors"><div class="titlepage"><div><div><h3 class="title"><a name="sec_types_constr"></a>Types and constructors</h3></div></div></div><p>The natural meaning of type is the "characterisation of term". But in fact that "characterisation" can be
		fulfilled by the specific function - constructor, that creates this specific term.</p><p>So we will mean "constructor" saying "type", and consider type as proper constructor name.</p></div><div class="sect2" title="Types of data"><div class="titlepage"><div><div><h3 class="title"><a name="sec_types_data"></a>Types of data</h3></div></div></div><p>There is no specific way of data representation in DEST. Instead of that the normal term is used to specify data.</p><p>DEST interpreter uses resolution method described further for understanding if the term is function or data.</p><p>For avoiding problems with resolution, the constructor can be defined that accepts the raw term as argument,
		and results in specific type of data:</p><pre class="programlisting">
		add 4 TInt abba
	    </pre><p>Here "TInt" is constructor that represents the input "abba" as integer data.</p></div><div class="sect2" title="Predefined types"><div class="titlepage"><div><div><h3 class="title"><a name="sec_types_predef"></a>Predefined types</h3></div></div></div><p>There are the following predefined data types supported</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">Bool - boolean</li><li class="listitem">Int - standard signed integer</li><li class="listitem">Uint - standard unsigned integer</li><li class="listitem">Float - standard float</li><li class="listitem">[type] - tuple, where "type" desingates the type of data</li><li class="listitem">Struct - combination of not-unitype data fields (the analogue of struct in C++)</li></ul></div></div><div class="sect2" title="User defined type"><div class="titlepage"><div><div><h3 class="title"><a name="sec_types_userdef"></a>User defined type</h3></div></div></div><p>User can specify custom type via already defined types (constructors) just by using base notation for definition.</p><p>In fact any defined term can be used as a new type. In this case that term will be used as a constructor.</p><p>In example below the function "Complex" is defined. This function can be use as a constructor of expression of type 
	    "Complex":</p><pre class="programlisting">
		let Complex x y :: Struct Float Float := Struct (R::Float I::Float) x y
		let cc1 :: Complex := Complex 4.0 6.0
	    </pre></div><div class="sect2" title="Raw term type"><div class="titlepage"><div><div><h3 class="title"><a name="sec_types_raw"></a>Raw term type</h3></div></div></div><p>As we mentioned there is no specific type for initial data in DESL. The reqular term is used instead. The
		only difference is that such terms don't have the type specified. So to handle this terms in common manner we inroduce specific
		type for that desgnated as "-".</p></div><div class="sect2" title="The case of unknown type"><div class="titlepage"><div><div><h3 class="title"><a name="sec_types_unknown"></a>The case of unknown type</h3></div></div></div><p>It is possible that the the "type-res" for expression is not clear at the moment when expression is defined.
		For example the function that results in value of field of structure cannot know what will be the type of that fied. </p><p>In this case we will designate this type with symbol "*". So the type of function "Fld" will be as:</p><pre class="programlisting"> * Struct String </pre></div></div><div class="sect1" title="Expression evaluation"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_eval"></a>Expression evaluation</h2></div></div></div><div class="sect2" title="Evaluation rules"><div class="titlepage"><div><div><h3 class="title"><a name="sec_eval_rules"></a>Evaluation rules</h3></div></div></div><p>Evaluation of expression starts from left to right and is performed by applying the arguments recursivelly.</p><p>Let's consider the example below:</p><pre class="programlisting">
		let KMaxMass :: Int := 100
		set add inp self div KMaxMass inp mass
	    </pre><p>Where </p><pre class="programlisting">
		set :: Int Int  - embedded function that sets the state data
		add :: Int Int Int  - embedded function
		inp :: Int String  - embedded function resuting in state input data 
		div :: Int Int Int - embedded functon dividing the arguments
	    </pre><p>The schema of this expression evaluation is as:</p><pre class="programlisting">
		set add inp self div KMaxMass inp mass
		|-- add inp self div KMaxMass inp mass
		|-----  inp self div KMaxMass inp mass
		-----|  inp'
		|-- add inp'     div KMaxMass inp mass
		|-- add'         div KMaxMass inp mass
		|--              div KMaxMass inp mass
		|--                  KMaxMass inp mass
		--|                  KMaxMass' 
		|--              div KMaxMass' inp mass
		|--              div'         inp mass
		|--                           inp mass
		--|                           inp'
		|--              div'         inp'
		--|              div''
		|-- add'         div''
		--| add''
		set add''

		where
		|--  x ...    means "expression x applied to its argument"
		--|  x        means "expression x application results returns" 
		x'            means "result of expression x applied one argument" etc.
	    </pre></div><div class="sect2" title="Arguments resolution using type information"><div class="titlepage"><div><div><h3 class="title"><a name="sec_eval_res"></a>Arguments resolution using type information</h3></div></div></div><p>Terms resolution is the important feature that makes the language applicable. This is because we would like not to
		have requirement that all terms shall be unique. Otherwize the language would be rather inconvenient for usage.
		But if the terms are not unique than we can face several problems. The one problem is that there will be more that one 
		candidate for the argument when applying expression:</p><pre class="programlisting">
		let arg :: Int :: inc 1
		let arg :: Float :: 6.0
		let myfun x :: Int Int := add x x
		myfun arg
	    </pre><p>Here it is ambiguous for "myfun" which "arg" to be applied to, the "Int" or "Float". The name resolution
		is needed to select the correct expr.</p><p>Another case is when the type of argument doesn't meet the required type. The example is:</p><pre class="programlisting">
		let Complex x y :: Struct Float Float := Struct (R::Float I::Float) x y
		let rr :: Int := 5
		let ii :: Int := 6
		let cc1 :: Complex := Complex rr ii
	    </pre><p>Constructor "Complex" requests argument of type "Float", but type "Int" presented instead. The approach 
		here is the look at constructor of Float that accept Int arguments, and then use the constructor to "cast" the 
		Int argument to the Float one.</p><p>One more case is the argument of unknown type (ref <a class="xref" href="#sec_types_unknown" title="The case of unknown type">the section called &#8220;The case of unknown type&#8221;</a>. Expr simply doesn't have
		any information of argument type, so cannot apply it properly.  </p><pre class="programlisting">
		let mystruct :: Struct := Struct (Fi::Int Ff::Float) 4 7.0
		let dd :: Int := inc Fld mystruct Fi
	    </pre><p>So expr "inc" requires Int type but at the moment of applying arguments for "inc" the type of argument
	    "Fld" is unknown.</p><p> The possible solution here is to "believe" that the argument will be of the correct type after 
		evaluation and thus evaluate it first, and then apply. 
		</p><p>The name resolution based on type of expression. When evaluating, the expression selects the argument with 
		compatible type. Resolution algirithm handling all these cases are outlined below:</p><div class="figure"><a name="fig_name_resol_01"></a><p class="title"><b>Figure 2. </b></p><div class="figure-contents"><img src="fig_name_resol_01.png"></div></div><br class="figure-break"></div></div><div class="sect1" title="Implementation of interpreter"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_impl"></a>Implementation of interpreter</h2></div></div></div><p>As we can see the process of evaluating of expressions is recursive. This allows simplifying the 
	    implenetation of interpreter. The structure of interpeter is outlined by class diagram below.</p><p>The base functionality of expression evaluating is implemented with expression base class CSL_ExprBase. 
	    Its methos ApplyArgs includes the logic of terms resolution by the type (ref. <a class="xref" href="#sec_eval_res" title="Arguments resolution using type information">the section called &#8220;Arguments resolution using type information&#8221;</a>).</p><p>All predefined expressions are inherited from the base class and overwrite mainly two methods - 
	    Apply and Clone. Apply method implements expression specific function, for instance adding argument for embedded
	    function "add".</p><p>One more custom expression is CSL_FunBase - user defined function. It implements mapping functin variable to the arguments being 
	    applied.</p><div class="figure"><a name="fig_class_dgm"></a><p class="title"><b>Figure 3. </b></p><div class="figure-contents"><img src="fig_class_dgm.png"></div></div><br class="figure-break"><p>And finally CSL_Interpr - interpreter just goes line by line thru transition, evaluates expressions, and
	    keeps evaluated expression in order to provide them when next expression tries to resolve the terms.</p><p>Interpreter method EvalTrans can be launched in context of DES system or state. This context is passed to
	the method so interpreter can understand what should be result of transition evaluation.</p><p>In case of state context the interpreter performs setting the final result of transition evaluaton to the state.</p></div><div class="sect1" title="Example: Snails"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_snails"></a>Example: Snails</h2></div></div></div><div class="sect2" title='"Snails with DESL vs. Snails with C++ transitions'><div class="titlepage"><div><div><h3 class="title"><a name="sec_snails_vs"></a>"Snails with DESL vs. Snails with C++ transitions</h3></div></div></div><p>There was demo application snails described in <a class="xref" href="#ref_ybor_using_des" title="Y.Borisov, A.Lemekhova. Using of Synchronous Discrete Time System paradigm in software development">[<abbr class="abbrev">YBOR_USING_DES_</abbr>]</a> where transition
		functions were implemented on C++.</p><p>Let's compare initial implementation of "Snails" demo to the implementation using embedded transition
		functions written on DEST.</p><div class="figure"><a name="fig_cpp_vs_desl"></a><p class="title"><b>Figure 4. </b></p><div class="figure-contents"><img src="fig_cpp_vs_desl.png"></div></div><br class="figure-break"></div></div><div class="sect1" title="Discussion"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec_disc"></a>Discussion</h2></div></div></div><p>We have presented simple functional languge for transition function in the scope of DES general
	    languge.  We have shown solutions for the key algorithms of language interpretation.</p><p>We outline the important use cases and approaches of how they can be implemented. 
	    Finally we compare transition functions implemented in C++ and DEST on simple demo application.</p><p>We argue therefore that using the proposed language makes DES programs more compact and efficient.</p></div></div></body></html>
